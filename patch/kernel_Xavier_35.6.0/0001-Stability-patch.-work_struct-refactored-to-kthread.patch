From b879a0966113e0b0601b4dd7e9c090d33618e37e Mon Sep 17 00:00:00 2001
From: "/setup.sh" <support@vision-components.com>
Date: Thu, 8 Jan 2026 16:19:38 +0100
Subject: [PATCH] Stability patch. work_struct refactored to kthread.

---
 .../kernel-5.10/drivers/mailbox/tegra-hsp.c   |  3 +-
 .../platform/tegra/rtcpu/capture-ivc-priv.h   | 10 +++-
 .../platform/tegra/rtcpu/capture-ivc.c        | 59 ++++++++++++++++---
 3 files changed, 59 insertions(+), 13 deletions(-)

diff --git a/kernel/kernel-5.10/drivers/mailbox/tegra-hsp.c b/kernel/kernel-5.10/drivers/mailbox/tegra-hsp.c
index a5c8c29..b8dca02 100644
--- a/kernel/kernel-5.10/drivers/mailbox/tegra-hsp.c
+++ b/kernel/kernel-5.10/drivers/mailbox/tegra-hsp.c
@@ -390,7 +390,6 @@ static void tegra_hsp_mailbox_receive_32bit_data(
 	value = tegra_hsp_channel_readl(channel, HSP_SM_SHRD_MBOX);
 	value &= ~HSP_SM_SHRD_MBOX_FULL;
 	msg = (void *)(unsigned long)value;
-	mbox_chan_received_data(channel->chan, msg);
 
 	/*
 	 * Need to clear all bits here since some
@@ -402,6 +401,8 @@ static void tegra_hsp_mailbox_receive_32bit_data(
 	 * make sure we cover all possible cases.
 	 */
 	tegra_hsp_channel_writel(channel, 0x0, HSP_SM_SHRD_MBOX);
+
+	mbox_chan_received_data(channel->chan, msg);
 }
 
 static const struct tegra_hsp_sm_ops tegra_hsp_sm_32bit_ops = {
diff --git a/kernel/nvidia/drivers/platform/tegra/rtcpu/capture-ivc-priv.h b/kernel/nvidia/drivers/platform/tegra/rtcpu/capture-ivc-priv.h
index c4eaa4e..5f29d98 100644
--- a/kernel/nvidia/drivers/platform/tegra/rtcpu/capture-ivc-priv.h
+++ b/kernel/nvidia/drivers/platform/tegra/rtcpu/capture-ivc-priv.h
@@ -53,7 +53,11 @@ struct tegra_capture_ivc {
 	/** Channel write lock */
 	struct mutex ivc_wr_lock;
 	/** Deferred work */
-	struct work_struct work;
+	struct kthread_work work;
+	/** ivc worker thread **/
+	struct kthread_worker ivc_worker;
+	/** task struct **/
+	struct task_struct *ivc_kthread;
 	/** Channel work queue head */
 	wait_queue_head_t write_q;
 	/** Array holding callbacks registered by each channel */
@@ -98,10 +102,10 @@ static struct tegra_capture_ivc *__scivc_capture;
  * @brief Worker thread to handle the asynchronous msgs on the IVC channel.
 	This will further calls callbacks registered by Channel drivers.
  *
- * @param[in]	work	work_struct pointer
+ * @param[in]	work	kthread_work pointer
  */
 static void tegra_capture_ivc_worker(
-	struct work_struct *work);
+	struct kthread_work *work);
 
 /**
  * @brief Implementation of IVC notify operation which gets called when we any
diff --git a/kernel/nvidia/drivers/platform/tegra/rtcpu/capture-ivc.c b/kernel/nvidia/drivers/platform/tegra/rtcpu/capture-ivc.c
index 48acf32..4a441d6 100644
--- a/kernel/nvidia/drivers/platform/tegra/rtcpu/capture-ivc.c
+++ b/kernel/nvidia/drivers/platform/tegra/rtcpu/capture-ivc.c
@@ -31,6 +31,13 @@
 #include <linux/tegra-ivc-bus.h>
 #include <linux/nospec.h>
 #include <linux/semaphore.h>
+
+#include <linux/kthread.h>
+#include <linux/sched.h>
+#include <linux/version.h>
+#if KERNEL_VERSION(4, 14, 0) < LINUX_VERSION_CODE
+#include <uapi/linux/sched/types.h>
+#endif
 #include <asm/barrier.h>
 
 #include "capture-ivc-priv.h"
@@ -368,7 +375,7 @@ static inline void tegra_capture_ivc_recv(struct tegra_capture_ivc *civc)
 	}
 }
 
-static void tegra_capture_ivc_worker(struct work_struct *work)
+static void tegra_capture_ivc_worker(struct kthread_work *work)
 {
 	struct tegra_capture_ivc *civc;
 	struct tegra_ivc_channel *chan;
@@ -398,7 +405,7 @@ static void tegra_capture_ivc_notify(struct tegra_ivc_channel *chan)
 
 	/* Only 1 thread can wait on write_q, rest wait for write_lock */
 	wake_up(&civc->write_q);
-	schedule_work(&civc->work);
+	kthread_queue_work(&civc->ivc_worker, &civc->work);
 }
 
 #define NV(x) "nvidia," #x
@@ -410,6 +417,8 @@ static int tegra_capture_ivc_probe(struct tegra_ivc_channel *chan)
 	const char *service;
 	int ret;
 	uint32_t i;
+	int32_t prio = 0;
+	struct sched_param sparm = {.sched_priority = 99};
 
 	civc = devm_kzalloc(dev, (sizeof(*civc)), GFP_KERNEL);
 	if (unlikely(civc == NULL))
@@ -422,6 +431,12 @@ static int tegra_capture_ivc_probe(struct tegra_ivc_channel *chan)
 		return ret;
 	}
 
+	if (of_property_read_u32(dev->of_node, NV(priority), &prio)) {
+		dev_info(dev, "no priority specified, using 99 as default\n");
+		prio = 99;
+	}
+	sparm.sched_priority = prio;
+
 	civc->chan = chan;
 
 	mutex_init(&civc->cb_ctx_lock);
@@ -431,7 +446,22 @@ static int tegra_capture_ivc_probe(struct tegra_ivc_channel *chan)
 		sema_init(&civc->cb_ctx[i].sem_ch, 1);
 
 	/* Initialize ivc_work */
-	INIT_WORK(&civc->work, tegra_capture_ivc_worker);
+//	INIT_WORK(&civc->work, tegra_capture_ivc_worker);
+
+	/* Initialize kworker */
+	kthread_init_work(&civc->work, tegra_capture_ivc_worker);
+
+	kthread_init_worker(&civc->ivc_worker);
+
+	civc->ivc_kthread = kthread_create(&kthread_worker_fn,
+			&civc->ivc_worker, service);
+	if (IS_ERR(civc->ivc_kthread)) {
+		dev_err(dev, "Cannot allocate ivc worker thread\n");
+		ret = PTR_ERR(civc->ivc_kthread);
+		goto err;
+	}
+	sched_setscheduler(civc->ivc_kthread, SCHED_RR, &sparm);
+	wake_up_process(civc->ivc_kthread);
 
 	/* Initialize wait queue */
 	init_waitqueue_head(&civc->write_q);
@@ -447,26 +477,37 @@ static int tegra_capture_ivc_probe(struct tegra_ivc_channel *chan)
 	tegra_ivc_channel_set_drvdata(chan, civc);
 
 	if (!strcmp("capture-control", service)) {
-		if (WARN_ON(__scivc_control != NULL))
-			return -EEXIST;
+		if (WARN_ON(__scivc_control != NULL)) {
+			ret = -EEXIST;
+			goto err_service;
+		}
 		__scivc_control = civc;
 	} else if (!strcmp("capture", service)) {
-		if (WARN_ON(__scivc_capture != NULL))
-			return -EEXIST;
+		if (WARN_ON(__scivc_capture != NULL)) {
+			ret = -EEXIST;
+			goto err_service;
+		}
 		__scivc_capture = civc;
 	} else {
 		dev_err(dev, "Unknown ivc channel %s\n", service);
-		return -EINVAL;
+		ret = -EINVAL;
+		goto err_service;
 	}
 
 	return 0;
+
+err_service:
+	kthread_stop(civc->ivc_kthread);
+err:
+	return ret;
 }
 
 static void tegra_capture_ivc_remove(struct tegra_ivc_channel *chan)
 {
 	struct tegra_capture_ivc *civc = tegra_ivc_channel_get_drvdata(chan);
 
-	cancel_work_sync(&civc->work);
+	kthread_flush_worker(&civc->ivc_worker);
+	kthread_stop(civc->ivc_kthread);
 
 	if (__scivc_control == civc)
 		__scivc_control = NULL;
-- 
2.34.1

